<script>
    const cbtContainer = document.getElementById('cbt-container');
    const cbtBackground = document.getElementById('cbt-background');
    const cbtText = document.getElementById('cbt-text');
    const cbtOverlay = document.getElementById('cbt-overlay');
    const cornerCounter = document.getElementById('corner-counter');
    const confettiContainer = document.getElementById('confetti-container');
    const statsDisplay = document.getElementById('stats-display');
    const cornerCountSpan = document.getElementById('corner-count');
    const loading = document.getElementById('loading');

    let statsVisible = false;
    let x, y, dx, dy;
    let cornerHits = parseInt(localStorage.getItem('cornerHits') || '0', 10);
    let lastCornerTime = Date.now();
    let currentColor = '#ff0000';

    function getRandomColor() {
        const colors = [
            '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
            '#ff8000', '#8000ff', '#0080ff', '#80ff00', '#ff0080', '#8080ff'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    function getInitialState() {
        const screenWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
        const screenHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
        const cbtWidth = Math.max(120, Math.min(240, screenWidth * 0.25));
        const cbtHeight = Math.max(50, Math.min(100, screenHeight * 0.10));

        return {
            x: Math.random() * (screenWidth - cbtWidth),
            y: Math.random() * (screenHeight - cbtHeight),
            dx: (Math.random() > 0.5 ? 1 : -1) * Math.max(2, screenWidth * 0.003),
            dy: (Math.random() > 0.5 ? 1 : -1) * Math.max(2, screenHeight * 0.003),
            cornerHits: cornerHits,
            lastCornerTime: Date.now(),
            currentColor: getRandomColor()
        };
    }

    function updateDisplay() {
        cornerCountSpan.textContent = cornerHits;
        cbtOverlay.style.backgroundColor = currentColor;
    }

    function updatePosition() {
        cbtContainer.style.left = x + 'px';
        cbtContainer.style.top = y + 'px';
    }

    function createConfetti() {
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8000', '#8000ff', '#ffffff', '#ffd700'];
        const shapes = ['circle', 'square', 'triangle'];

        for (let i = 0; i < 150; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';

            const spawnSide = Math.random();
            let startX, startY, endX, endY;

            if (spawnSide < 0.6) {
                startX = Math.random() * 100;
                startY = -10;
                endX = startX + (Math.random() - 0.5) * 40;
                endY = 110;
            } else if (spawnSide < 0.8) {
                startX = -10;
                startY = Math.random() * 50;
                endX = Math.random() * 100 + 50;
                endY = Math.random() * 50 + 50;
            } else {
                startX = 110;
                startY = Math.random() * 50;
                endX = Math.random() * 50 - 10;
                endY = Math.random() * 50 + 50;
            }

            confetti.style.left = startX + '%';
            confetti.style.top = startY + '%';

            const color = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.backgroundColor = color;

            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            if (shape === 'circle') {
                confetti.style.borderRadius = '50%';
            } else if (shape === 'triangle') {
                confetti.style.width = '0';
                confetti.style.height = '0';
                confetti.style.backgroundColor = 'transparent';
                confetti.style.borderLeft = '5px solid transparent';
                confetti.style.borderRight = '5px solid transparent';
                confetti.style.borderBottom = `10px solid ${color}`;
            }

            const size = Math.random() * 10 + 3;
            if (shape !== 'triangle') {
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
            }

            const duration = Math.random() * 2 + 2.5;
            const delay = Math.random() * 0.8;
            const rotation = Math.random() * 1440 + 360;

            confetti.style.transition = `all ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
            confetti.style.transitionDelay = delay + 's';

            confettiContainer.appendChild(confetti);

            setTimeout(() => {
                confetti.style.left = endX + '%';
                confetti.style.top = endY + '%';
                confetti.style.transform = `rotate(${rotation}deg) scale(0.1)`;
                confetti.style.opacity = '0';
            }, 50);

            setTimeout(() => {
                if (confetti.parentNode) {
                    confetti.parentNode.removeChild(confetti);
                }
            }, (duration + delay) * 1000 + 1000);
        }
    }

    function showCornerHit() {
        cornerHits++;
        localStorage.setItem('cornerHits', cornerHits);
        cornerCounter.textContent = `Corner Hits: ${cornerHits}`;
        cornerCountSpan.textContent = cornerHits;
        console.log(`ðŸŽ‰ CORNER HIT #${cornerHits}! Time since last: ${(Date.now() - lastCornerTime) / 1000}s`);
        lastCornerTime = Date.now();
        createConfetti();
    }

    function isCornerHit(newX, newY, screenWidth, screenHeight, cbtWidth, cbtHeight) {
        const tolerance = 5;
        const leftEdge = newX <= tolerance;
        const rightEdge = newX >= screenWidth - cbtWidth - tolerance;
        const topEdge = newY <= tolerance;
        const bottomEdge = newY >= screenHeight - cbtHeight - tolerance;
        return (leftEdge || rightEdge) && (topEdge || bottomEdge);
    }

    let lastFrameTime = 0;
    const targetFPS = 60;
    const frameInterval = 1000 / targetFPS;

    function animate(currentTime = 0) {
        if (currentTime - lastFrameTime < frameInterval) {
            requestAnimationFrame(animate);
            return;
        }
        lastFrameTime = currentTime;

        const screenWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
        const screenHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
        const cbtWidth = Math.max(120, Math.min(240, screenWidth * 0.25));
        const cbtHeight = Math.max(50, Math.min(100, screenHeight * 0.10));

        let newX = x + dx;
        let newY = y + dy;
        let hitWall = false;
        let hitCorner = false;

        if (newX + cbtWidth >= screenWidth) {
            newX = screenWidth - cbtWidth;
            dx = -Math.abs(dx);
            hitWall = true;
        } else if (newX <= 0) {
            newX = 0;
            dx = Math.abs(dx);
            hitWall = true;
        }

        if (newY + cbtHeight >= screenHeight) {
            newY = screenHeight - cbtHeight;
            dy = -Math.abs(dy);
            hitWall = true;
        } else if (newY <= 0) {
            newY = 0;
            dy = Math.abs(dy);
            hitWall = true;
        }

        if (hitWall && isCornerHit(newX, newY, screenWidth, screenHeight, cbtWidth, cbtHeight)) {
            hitCorner = true;
            showCornerHit();
        }

        x = newX;
        y = newY;

        if (hitWall) {
            currentColor = getRandomColor();
            cbtOverlay.style.backgroundColor = currentColor;
            if (hitCorner) {
                cbtOverlay.style.opacity = '0.6';
                setTimeout(() => {
                    cbtOverlay.style.opacity = '0.3';
                }, 500);
            }
        }

        updatePosition();
        updateDisplay();
        requestAnimationFrame(animate);
    }

    let currentZoom = 1;

    function adjustMobileZoom() {
        if (window.innerWidth <= 768) {
            const vh = window.innerHeight;
            const vw = window.innerWidth;
            if (vh < 600 || vw < 400) currentZoom = 0.7;
            else if (vh < 700 || vw < 500) currentZoom = 0.8;
            else currentZoom = 0.9;
            document.body.style.transform = `scale(${currentZoom})`;
            document.body.style.transformOrigin = 'center center';
        } else {
            document.body.style.transform = 'scale(1)';
            currentZoom = 1;
        }
    }

    adjustMobileZoom();
    window.addEventListener('resize', adjustMobileZoom);

    document.addEventListener('click', (e) => {
        statsVisible = !statsVisible;
        statsDisplay.style.display = statsVisible ? 'block' : 'none';
    });

    document.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) e.preventDefault();
    });

    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            adjustMobileZoom();
            window.dispatchEvent(new Event('resize'));
        }, 100);
    });

    window.addEventListener('resize', () => {
        const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
        const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
        let widthPercent = 0.25, heightPercent = 0.10;
        if (viewportWidth <= 768) { widthPercent = 0.30; heightPercent = 0.12; }
        if (viewportWidth <= 480) { widthPercent = 0.35; heightPercent = 0.14; }

        const newWidth = Math.max(120, Math.min(240, viewportWidth * widthPercent));
        const newHeight = Math.max(50, Math.min(100, viewportHeight * heightPercent));

        cbtContainer.style.width = newWidth + 'px';
        cbtContainer.style.height = newHeight + 'px';

        if (x !== null && y !== null) {
            x = Math.min(x, viewportWidth - newWidth);
            y = Math.min(y, viewportHeight - newHeight);
            x = Math.max(x, 0);
            y = Math.max(y, 0);
            updatePosition();
        }
    });

    // Preload and handle image loading with timeout
    const images = [
        { id: 'cbt-background', src: '/assets/cbt-background.png' },
        { id: 'cbt-text', src: '/assets/cbt-text.png' }
    ];
    let imagesLoaded = 0;

    function preloadImages() {
        images.forEach(({ id, src }) => {
            const img = new Image();
            img.src = src;
            img.onload = () => {
                console.log(`Loaded ${src} successfully`);
                imagesLoaded++;
                if (id === 'cbt-background') {
                    cbtBackground.style.backgroundImage = `url(${src})`;
                    console.log(`Applied background: ${src}`);
                } else if (id === 'cbt-text') {
                    cbtText.src = src;
                    cbtText.style.display = 'block';
                    console.log(`Applied text: ${src}`);
                }
                checkLoadComplete();
            };
            img.onerror = () => {
                console.error(`Failed to load ${src}, using fallback color`);
                imagesLoaded++; // Increment to avoid hang
                checkLoadComplete();
            };
        });

        // Timeout to prevent infinite loading
        setTimeout(() => {
            if (imagesLoaded < images.length) {
                console.warn('Image load timeout, proceeding with fallback');
                imagesLoaded = images.length; // Force completion
                checkLoadComplete();
            }
        }, 3000); // 3-second timeout
    }

    function checkLoadComplete() {
        if (imagesLoaded === images.length) {
            console.log('All images loaded or timed out, showing container');
            loading.style.display = 'none';
            cbtContainer.style.visibility = 'visible';
            const ogImage = document.querySelector('meta[property="og:image"]');
            if (ogImage) ogImage.content = '/assets/ogimage.png';
        }
    }

    // Initialize and start
    const initialState = getInitialState();
    x = initialState.x;
    y = initialState.y;
    dx = initialState.dx;
    dy = initialState.dy;
    cornerHits = initialState.cornerHits;
    lastCornerTime = initialState.lastCornerTime;
    currentColor = initialState.currentColor;

    cbtContainer.style.width = Math.max(120, Math.min(240, Math.min(window.innerWidth, document.documentElement.clientWidth) * 0.25)) + 'px';
    cbtContainer.style.height = Math.max(50, Math.min(100, Math.min(window.innerHeight, document.documentElement.clientHeight) * 0.10)) + 'px';

    updateDisplay();
    updatePosition();
    preloadImages();
    requestAnimationFrame(animate);
</script>
